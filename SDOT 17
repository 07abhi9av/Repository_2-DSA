MINIMUM DELETIONS TO MAKE ARRAYS DIVISIBLE
You are given two positive integer arrays nums and numsDivide. You can delete any number of elements from nums.
Return the minimum number of deletions such that the smallest element in nums divides all the elements of numsDivide.
If this is not possible, return -1.
Note that an integer x divides y if y % x == 0.
Input
Input must be in 2 lines.
1st Line, Enter the interger array 'nums' as space seperated values. 
2nd Line, Enter the interger array 'numsDivide' as space seperated values. 
Output
Return the min no of deletion as integer. If this is not possible, return -1.
Example
Input:

2 3 2 4 3
9 6 9 3 15
Output:

2


class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        x = numsDivide[0]
        for v in numsDivide[1:]:
            x = gcd(x, v)
        nums.sort()
        for i, v in enumerate(nums):
            if x % v == 0:
                return i
        return -1


from typing import List
from math import gcd

class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        x = numsDivide[0]
        for v in numsDivide[1:]:
            x = gcd(x, v)
        nums.sort()
        for i, v in enumerate(nums):
            if x % v == 0:
                return i
        return -1

# Input
nums = list(map(int, input().split()))
numsDivide = list(map(int, input().split()))

# Instantiate Solution class
solution = Solution()

# Output
print(solution.minOperations(nums, numsDivide))



MERGE K SORTED LINKED LISTS
You are given an array of k linkedlists, where each linked list is sorted in ascending order. 
Write a Java program to merge all the linked lists into a single linked list and return it.
Input
An integer `k` representing the number of linkedlists. 
For each linkedlist:
An integer `size` representing the number of elements in the linkedlist.
`size` integers representing the elements of the linkedlist in sorted order.
Output
A single line containing the elements of the merged linked list in sorted order.
Example
Input:

2
4
1 4 5 6
3
1 2 4 5
Output:

1 1 2 4 4 5 6





class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeKLists(lists):
    from heapq import heappush, heappop
    heap = []
    for lst in lists:
        while lst:
            heappush(heap, lst.val)
            lst = lst.next

    dummy = ListNode()
    curr = dummy
    while heap:
        val = heappop(heap)
        curr.next = ListNode(val)
        curr = curr.next

    return dummy.next

# Taking user input
k = int(input("Enter the number of linked lists: "))
lists = []
for _ in range(k):
    size = int(input("Enter the size of the linked list: "))
    elements = list(map(int, input("Enter the elements of the linked list in sorted order: ").split()))
    head = ListNode(elements[0])
    curr = head
    for val in elements[1:]:
        curr.next = ListNode(val)
        curr = curr.next
    lists.append(head)

# Merging k sorted linked lists
merged_head = mergeKLists(lists)

# Printing the merged linked list
while merged_head:
    print(merged_head.val, end=" ")
    merged_head = merged_head.next


TRAPPING RAIN WATER
Given with n non-negative integers representing an elevation map 
where the width of each bar is 1, we need to compute how much water it is able to trap after raining.
Input
Enter the elevation map elements separated by spaces
Output
Print the Amount of water trapped 
Example
Input:

3 0 2 0 4
Output:

7


def trap_rain_water(elevation_map):
    if not elevation_map:
        return 0

    left, right = 0, len(elevation_map) - 1
    left_max = right_max = 0
    water_trapped = 0

    while left < right:
        if elevation_map[left] < elevation_map[right]:
            if elevation_map[left] >= left_max:
                left_max = elevation_map[left]
            else:
                water_trapped += left_max - elevation_map[left]
            left += 1
        else:
            if elevation_map[right] >= right_max:
                right_max = elevation_map[right]
            else:
                water_trapped += right_max - elevation_map[right]
            right -= 1

    return water_trapped

# Taking input from the user
elevation_map = list(map(int, input("Enter the elevation map elements separated by spaces: ").split()))

# Calculating and printing the amount of water trapped
print("Amount of water trapped:", trap_rain_water(elevation_map))
